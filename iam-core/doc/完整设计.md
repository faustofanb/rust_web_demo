# IAM Core 系统设计文档

> 注：本文档包含系统的完整设计，包括核心抽象、具体实现、扩展设计等内容。

## 1. 系统概览

### 1.1 业务领域
IAM Core 是一个基于 Rust 开发的身份与访问管理系统，提供：
- 身份认证
- 访问控制
- 组织管理
- 权限管理
- 审计日志
- 多租户支持

### 1.2 技术选型
- 开发语言: Rust
- Web 框架: Axum
- 事件存储: MySQL (SQLx)
- 读模型存储: MySQL (Sea-ORM)
- 消息队列: Kafka
- 缓存: Redis
- 监控: Prometheus + Grafana
- 日志: ELK Stack

### 1.3 架构模式
- 领域驱动设计 (DDD)
- 命令查询职责分离 (CQRS)
- 事件溯源 (Event Sourcing)
- 微服务架构

## 2. 核心抽象层设计

### 2.1 基础抽象

#### 2.1.1 标识符与元数据
```rust
/// 所有ID的基础特征
pub trait Identifier: Clone + Debug + Send + Sync {
    /// 获取ID的字符串表示
    fn value(&self) -> &str;
    
    /// 从字符串创建ID
    fn from_string(s: &str) -> Result<Self> where Self: Sized;
    
    /// ID类型
    fn type_name(&self) -> &str;
}

/// 元数据特征
pub trait Metadata: Clone + Debug + Send + Sync {
    /// 获取租户ID
    fn tenant_id(&self) -> Option<&TenantId>;
    
    /// 获取元数据项
    fn get(&self, key: &str) -> Option<&Value>;
    
    /// 设置元数据项
    fn set(&mut self, key: &str, value: Value);
    
    /// 序列化
    fn to_json(&self) -> Result<Value>;
}
```

#### 2.1.2 值对象基础
```rust
/// 值对象特征
pub trait ValueObject: Clone + Debug + Eq + Send + Sync {
    /// 验证值对象
    fn validate(&self) -> Result<()>;
    
    /// 序列化为JSON
    fn to_json(&self) -> Result<Value>;
    
    /// 从JSON反序列化
    fn from_json(json: Value) -> Result<Self> where Self: Sized;
}
```

### 2.2 领域层抽象

#### 2.2.1 实体基础特征
```rust
/// 实体基础特征
pub trait Entity: Send + Sync {
    /// 实体ID类型
    type Id: Identifier;
    
    /// 获取实体ID
    fn id(&self) -> &Self::Id;
    
    /// 获取版本号
    fn version(&self) -> u64;
    
    /// 获取创建时间
    fn created_at(&self) -> DateTime<Utc>;
    
    /// 获取更新时间
    fn updated_at(&self) -> DateTime<Utc>;
}
```

#### 2.2.2 聚合根特征
```rust
/// 聚合根特征
pub trait AggregateRoot: Entity {
    /// 聚合根类型
    type Type: Display + Send + Sync;
    
    /// 获取聚合根类型
    fn aggregate_type() -> Self::Type where Self: Sized;
    
    /// 从事件流重建状态
    fn from_events(events: Vec<Box<dyn DomainEvent>>) -> Result<Self> where Self: Sized;
    
    /// 应用事件
    fn apply_event(&mut self, event: Box<dyn DomainEvent>) -> Result<()>;
    
    /// 获取未提交的事件
    fn uncommitted_events(&self) -> &[Box<dyn DomainEvent>];
    
    /// 清除未提交的事件
    fn clear_uncommitted_events(&mut self);
    
    /// 验证聚合根状态
    fn validate(&self) -> Result<()>;
}
```

#### 2.2.3 领域事件特征
```rust
/// 领域事件特征
pub trait DomainEvent: Send + Sync + 'static {
    /// 事件ID
    fn event_id(&self) -> &EventId;
    
    /// 事件类型
    fn event_type(&self) -> &str;
    
    /// 聚合根ID
    fn aggregate_id(&self) -> &AggregateId;
    
    /// 聚合根类型
    fn aggregate_type(&self) -> &str;
    
    /// 事件发生时间
    fn occurred_at(&self) -> DateTime<Utc>;
    
    /// 事件版本
    fn version(&self) -> u32;
    
    /// 事件元数据
    fn metadata(&self) -> &EventMetadata;
    
    /// 序列化事件
    fn serialize(&self) -> Result<Value>;
    
    /// 反序列化事件
    fn deserialize(data: Value) -> Result<Box<dyn DomainEvent>>;
}

/// 事件构建器特征
pub trait EventBuilder<E: DomainEvent> {
    /// 设置聚合根ID
    fn aggregate_id(self, id: AggregateId) -> Self;
    
    /// 设置元数据
    fn metadata(self, metadata: EventMetadata) -> Self;
    
    /// 构建事件
    fn build(self) -> Result<E>;
}
```

### 2.3 应用层抽象

#### 2.3.1 命令处理
```rust
/// 命令特征
pub trait Command: Send + Sync {
    /// 命令类型
    fn command_type(&self) -> &str;
    
    /// 目标聚合根ID
    fn aggregate_id(&self) -> &AggregateId;
    
    /// 命令元数据
    fn metadata(&self) -> &CommandMetadata;
    
    /// 验证命令
    fn validate(&self) -> Result<()>;
}

/// 命令处理器特征
pub trait CommandHandler<C: Command> {
    /// 处理命令的结果类型
    type Result;
    
    /// 处理命令
    async fn handle(&self, command: C) -> Result<Self::Result>;
    
    /// 检查命令是否可以执行
    async fn can_handle(&self, command: &C) -> Result<()>;
}

/// 通用命令总线
pub trait CommandBus: Send + Sync {
    /// 分发命令
    async fn dispatch<C: Command>(&self, command: C) -> Result<()>;
    
    /// 注册命令处理器
    fn register<C: Command, H: CommandHandler<C>>(&mut self, handler: H);
}
```

#### 2.3.2 查询处理
```rust
/// 查询特征
pub trait Query: Send + Sync {
    /// 查询结果类型
    type Result;
    
    /// 查询类型
    fn query_type(&self) -> &str;
    
    /// 验证查询
    fn validate(&self) -> Result<()>;
}

/// 查询处理器特征
pub trait QueryHandler<Q: Query> {
    /// 处理查询
    async fn handle(&self, query: Q) -> Result<Q::Result>;
}

/// 查询总线
pub trait QueryBus: Send + Sync {
    /// 执行查询
    async fn execute<Q: Query>(&self, query: Q) -> Result<Q::Result>;
    
    /// 注册查询处理器
    fn register<Q: Query, H: QueryHandler<Q>>(&mut self, handler: H);
}
```

### 2.4 基础设施层抽象

#### 2.4.1 事件存储
```rust
/// 事件存储特征
pub trait EventStore: Send + Sync {
    /// 保存事件
    async fn save_events(&self, 
        aggregate_id: &AggregateId, 
        events: Vec<Box<dyn DomainEvent>>, 
        expected_version: u64
    ) -> Result<()>;
    
    /// 获取事件流
    async fn get_events(&self, 
        aggregate_id: &AggregateId
    ) -> Result<Vec<Box<dyn DomainEvent>>>;
    
    /// 获取特定版本之后的事件
    async fn get_events_since(&self,
        aggregate_id: &AggregateId,
        since_version: u64
    ) -> Result<Vec<Box<dyn DomainEvent>>>;
}
```

#### 2.4.2 读模型存储
```rust
/// 读模型特征
pub trait ReadModel: Send + Sync {
    /// 读模型ID类型
    type Id: Identifier;
    
    /// 获取ID
    fn id(&self) -> &Self::Id;
    
    /// 获取租户ID
    fn tenant_id(&self) -> Option<&TenantId>;
}

/// 读模型存储特征
pub trait ReadModelStore<T: ReadModel>: Send + Sync {
    /// 保存读模型
    async fn save(&self, model: T) -> Result<()>;
    
    /// 批量保存
    async fn save_batch(&self, models: Vec<T>) -> Result<()>;
    
    /// 根据ID获取
    async fn get_by_id(&self, id: &T::Id) -> Result<Option<T>>;
    
    /// 删除
    async fn delete(&self, id: &T::Id) -> Result<()>;
    
    /// 查询
    async fn query(&self, query: ReadModelQuery) -> Result<Vec<T>>;
}
```

#### 2.4.3 事件处理
```rust
/// 事件处理器特征
pub trait EventHandler: Send + Sync {
    /// 处理器名称
    fn name(&self) -> &str;
    
    /// 支持的事件类型
    fn supported_events(&self) -> &[&str];
    
    /// 处理事件
    async fn handle(&self, event: Box<dyn DomainEvent>) -> Result<()>;
    
    /// 检查是否可以处理事件
    fn can_handle(&self, event: &dyn DomainEvent) -> bool;
}

/// 事件总线特征
pub trait EventBus: Send + Sync {
    /// 发布事件
    async fn publish(&self, events: Vec<Box<dyn DomainEvent>>) -> Result<()>;
    
    /// 订阅事件
    fn subscribe(&mut self, handler: Box<dyn EventHandler>);
}
```

## 3. 具体实现示例

### 3.1 用户领域模型
```rust
#[derive(Debug, Clone)]
pub struct User {
    id: UserId,
    version: u64,
    tenant_id: TenantId,
    username: Username,
    email: Email,
    password: Password,
    status: UserStatus,
    roles: Vec<RoleId>,
    created_at: DateTime<Utc>,
    updated_at: DateTime<Utc>,
    uncommitted_events: Vec<Box<dyn DomainEvent>>,
}

impl AggregateRoot for User {
    type Type = &'static str;
    
    fn aggregate_type() -> Self::Type {
        "user"
    }
    
    fn from_events(events: Vec<Box<dyn DomainEvent>>) -> Result<Self> {
        let mut user = User::default();
        for event in events {
            user.apply_event(event)?;
        }
        Ok(user)
    }
    
    // ... 实现其他方法
}

// 用户相关命令
pub struct RegisterUserCommand {
    aggregate_id: AggregateId,
    tenant_id: TenantId,
    username: String,
    email: String,
    password: String,
    metadata: CommandMetadata,
}

impl Command for RegisterUserCommand {
    // ... 实现命令特征
}

// 用户相关事件
pub struct UserRegisteredEvent {
    event_id: EventId,
    aggregate_id: AggregateId,
    tenant_id: TenantId,
    username: String,
    email: String,
    occurred_at: DateTime<Utc>,
    metadata: EventMetadata,
}

impl DomainEvent for UserRegisteredEvent {
    // ... 实现事件特征
}
```

### 3.2 通用实现

#### 3.2.1 通用命令处理器
```rust
pub struct GenericCommandHandler<A: AggregateRoot> {
    event_store: Arc<dyn EventStore>,
    event_bus: Arc<dyn EventBus>,
    _phantom: PhantomData<A>,
}

impl<A: AggregateRoot> GenericCommandHandler<A> {
    pub async fn handle<C: Command>(&self, command: C) -> Result<()> {
        // 1. 验证命令
        command.validate()?;
        
        // 2. 加载聚合根
        let events = self.event_store
            .get_events(command.aggregate_id())
            .await?;
        let mut aggregate = A::from_events(events)?;
        
        // 3. 处理命令
        let new_events = aggregate.handle_command(command)?;
        
        // 4. 保存事件
        self.event_store
            .save_events(
                command.aggregate_id(),
                new_events.clone(),
                aggregate.version()
            )
            .await?;
            
        // 5. 发布事件
        self.event_bus.publish(new_events).await?;
        
        Ok(())
    }
}
```

#### 3.2.2 通用事件处理器
```rust
pub struct GenericEventHandler<T: ReadModel> {
    store: Arc<dyn ReadModelStore<T>>,
    supported_events: HashSet<String>,
    projection: Box<dyn Fn(Box<dyn DomainEvent>) -> Result<T>>,
}

impl<T: ReadModel> EventHandler for GenericEventHandler<T> {
    fn name(&self) -> &str {
        std::any::type_name::<T>()
    }
    
    fn supported_events(&self) -> &[&str] {
        &self.supported_events
            .iter()
            .map(|s| s.as_str())
            .collect::<Vec<_>>()
    }
    
    async fn handle(&self, event: Box<dyn DomainEvent>) -> Result<()> {
        if !self.can_handle(event.as_ref()) {
            return Ok(());
        }
        
        let model = (self.projection)(event)?;
        self.store.save(model).await
    }
    
    fn can_handle(&self, event: &dyn DomainEvent) -> bool {
        self.supported_events.contains(event.event_type())
    }
}
```

## 4. 最佳实践与模式

### 4.1 领域模型设计原则
1. 强一致性边界
   - 聚合根负责维护其内部状态的一致性
   - 一个事务只能修改一个聚合根

2. 充血模型
   - 领域对象包含业务逻辑
   - 避免贫血模型

3. 值对象不变性
   - 值对象创建后不可修改
   - 修改操作返回新实例

### 4.2 事件设计原则
1. 事件命名
   - 使用过去时态
   - 清晰表达已发生的事情

2. 事件内容
   - 包含必要的上下文信息
   - 避免包含冗余数据
   - 确保事件自包含

3. 版本控制
   - 事件架构要支持演化
   - 通过版本号管理兼容性

### 4.3 CQRS实践
1. 命令侧
   - 强一致性
   - 同步处理
   - 事务完整性

2. 查询侧
   - 最终一致性
   - 优化读取性能
   - 支持复杂查询

3. 数据同步
   - 通过事件投影
   - 异步更新读模型
   - 处理不一致窗口

### 4.4 性能优化
1. 事件存储
   - 批量保存事件
   - 事件快照
   - 并发控制

2. 读模型
   - 合适的索引
   - 缓存策略
   - 批量更新

3. 并发处理
   - 连接池管理
   - 异步处理
   - 任务调度

## 5. 部署与运维

### 5.1 服务配置
```toml
[server]
host = "0.0.0.0"
port = 3000
workers = 4

[database]
url = "mysql://user:pass@localhost:3306/iam"
max_connections = 10
idle_timeout = "300s"

[redis]
url = "redis://localhost:6379"
pool_size = 5

[kafka]
brokers = ["localhost:9092"]
group_id = "iam-service"

[jwt]
secret = "your-secret-key"
expires_in = 3600
```

### 5.2 监控指标
1. 业务指标
   - 用户注册数
   - 认证请求数
   - 授权检查数

2. 技术指标
   - API响应时间
   - 数据库连接数
   - 缓存命中率
   - 消息队列积压

3. 系统指标
   - CPU使用率
   - 内存使用
   - 磁盘IO
   - 网络流量

### 5.3 日志规范
```rust
#[derive(Debug, Serialize)]
pub struct LogEvent {
    timestamp: DateTime<Utc>,
    level: String,
    event: String,
    context: LogContext,
    metadata: HashMap<String, Value>,
}

#[derive(Debug, Serialize)]
pub struct LogContext {
    trace_id: String,
    tenant_id: Option<String>,
    user_id: Option<String>,
    service: String,
    operation: String,
}
```

## 6. 扩展设计

### 6.1 值对象系统设计

```rust
/// 所有值对象的基础特征
pub trait ValueObject: Clone + Debug + Eq + Send + Sync {
    /// 验证值对象
    fn validate(&self) -> Result<()>;
    
    /// 序列化为JSON
    fn to_json(&self) -> Result<Value>;
    
    /// 从JSON反序列化
    fn from_json(json: Value) -> Result<Self> where Self: Sized;
}

/// 通用的版本化值对象特征
pub trait VersionedValue: ValueObject {
    /// 获取版本号
    fn version(&self) -> u32;
    
    /// 创建新版本
    fn create_new_version(&self) -> Self;
    
    /// 比较版本
    fn is_newer_than(&self, other: &Self) -> bool;
}

/// 可变更的值对象特征
pub trait ChangeableValue: ValueObject {
    /// 变更类型
    type ChangeSet;
    
    /// 应用变更
    fn apply_change(&self, change: Self::ChangeSet) -> Result<Self> where Self: Sized;
    
    /// 验证变更
    fn validate_change(&self, change: &Self::ChangeSet) -> Result<()>;
}
```

### 6.2 领域服务抽象

```rust
/// 领域服务特征
pub trait DomainService: Send + Sync {
    /// 服务名称
    fn service_name(&self) -> &str;
    
    /// 服务版本
    fn version(&self) -> &str;
    
    /// 初始化服务
    async fn initialize(&self) -> Result<()>;
    
    /// 健康检查
    async fn health_check(&self) -> Result<bool>;
}

/// 通用的聚合根仓储特征
pub trait AggregateRepository<A: AggregateRoot>: Send + Sync {
    /// 保存聚合根
    async fn save(&self, aggregate: &A) -> Result<()>;
    
    /// 根据ID加载聚合根
    async fn load(&self, id: &A::Id) -> Result<Option<A>>;
    
    /// 删除聚合根
    async fn delete(&self, id: &A::Id) -> Result<()>;
    
    /// 检查聚合根是否存在
    async fn exists(&self, id: &A::Id) -> Result<bool>;
}
```

### 6.3 权限系统设计

```rust
/// 权限定义
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct Permission {
    id: PermissionId,
    name: String,
    resource_type: ResourceType,
    action: Action,
    conditions: Vec<Condition>,
}

/// 权限检查器
pub trait PermissionChecker: Send + Sync {
    /// 检查权限
    async fn check_permission(
        &self,
        user_id: &UserId,
        permission: &Permission,
        context: &RequestContext
    ) -> Result<bool>;
    
    /// 获取用户所有权限
    async fn get_user_permissions(
        &self,
        user_id: &UserId
    ) -> Result<Vec<Permission>>;
}

/// 基于策略的权限检查实现
pub struct PolicyBasedPermissionChecker {
    policy_store: Arc<dyn PolicyStore>,
    role_store: Arc<dyn RoleStore>,
    cache: Arc<dyn Cache>,
}
```

### 6.4 缓存系统设计

```rust
/// 缓存键生成器
pub trait CacheKeyGenerator: Send + Sync {
    /// 生成缓存键
    fn generate_key(&self, parts: &[&str]) -> String;
    
    /// 生成前缀
    fn generate_prefix(&self, category: &str) -> String;
}

/// 缓存特征
pub trait Cache: Send + Sync {
    /// 设置缓存
    async fn set<T: Serialize>(
        &self,
        key: &str,
        value: &T,
        ttl: Duration
    ) -> Result<()>;
    
    /// 获取缓存
    async fn get<T: DeserializeOwned>(
        &self,
        key: &str
    ) -> Result<Option<T>>;
    
    /// 删除缓存
    async fn delete(&self, key: &str) -> Result<()>;
    
    /// 批量删除
    async fn delete_by_pattern(&self, pattern: &str) -> Result<()>;
}

/// 多级缓存
pub struct MultiLevelCache {
    l1_cache: Arc<dyn Cache>, // 本地缓存
    l2_cache: Arc<dyn Cache>, // 分布式缓存
    key_generator: Arc<dyn CacheKeyGenerator>,
}
```

### 6.5 审计日志系统设计

```rust
/// 审计日志事件
#[derive(Debug, Serialize)]
pub struct AuditLogEvent {
    id: EventId,
    timestamp: DateTime<Utc>,
    actor: ActorContext,
    action: String,
    target: TargetContext,
    status: OperationStatus,
    metadata: HashMap<String, Value>,
}

/// 审计日志存储
pub trait AuditLogStore: Send + Sync {
    /// 记录审计日志
    async fn log_event(&self, event: AuditLogEvent) -> Result<()>;
    
    /// 查询审计日志
    async fn query_logs(
        &self,
        query: AuditLogQuery
    ) -> Result<Vec<AuditLogEvent>>;
    
    /// 清理过期日志
    async fn cleanup_expired_logs(&self, before: DateTime<Utc>) -> Result<u64>;
}

/// 审计日志中间件
pub struct AuditLogMiddleware {
    store: Arc<dyn AuditLogStore>,
    config: AuditLogConfig,
}
```

## 7. 测试策略

### 7.1 单元测试
```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_user_registration() {
        // 准备
        let command = RegisterUserCommand {
            // ...
        };
        
        // 执行
        let events = user.handle_command(command).unwrap();
        
        // 验证
        assert_eq!(events.len(), 1);
        assert!(events[0].is::<UserRegisteredEvent>());
    }
}
```

### 6.2 集成测试
```rust
#[tokio::test]
async fn test_user_api() {
    // 准备测试环境
    let app = create_test_app().await;
    
    // 执行请求
    let response = app
        .post("/api/v1/users")
        .json(&user_data)
        .send()
        .await;
        
    // 验证响应
    assert!(response.status().is_success());
    
    // 验证事件
    let events = get_events(user_id).await;
    assert_eq!(events.len(), 1);
}
```

### 6.3 性能测试
```rust
#[tokio::test]
async fn test_concurrent_user_creation() {
    let mut handles = vec![];
    
    // 创建多个并发请求
    for i in 0..100 {
        let handle = tokio::spawn(async move {
            let result = create_user(i).await;
            assert!(result.is_ok());
        });
        handles.push(handle);
    }
    
    // 等待所有请求完成
    for handle in handles {
        handle.await.unwrap();
    }
}
```

## 8. 开发计划

### 8.1 核心抽象层实现
- [ ] 实现值对象系统
  - [ ] 实现通用的 `ValueObject` 特征
  - [ ] 实现版本化值对象 `VersionedValue` 特征
  - [ ] 实现可变更值对象 `ChangeableValue` 特征
  - [ ] 添加值对象验证器

- [ ] 实现领域服务架构
  - [ ] 实现 `DomainService` 特征
  - [ ] 实现通用的聚合根仓储
  - [ ] 实现服务注册和发现机制
  - [ ] 添加服务生命周期管理

### 8.2 功能模块实现
- [ ] 实现权限系统
  - [ ] 实现 RBAC 权限模型
  - [ ] 实现基于策略的权限检查器
  - [ ] 实现权限缓存机制
  - [ ] 实现动态权限策略

- [ ] 实现多级缓存系统
  - [ ] 实现本地缓存（L1）
  - [ ] 实现分布式缓存（L2）
  - [ ] 实现缓存同步机制
  - [ ] 实现缓存管理功能

- [ ] 实现审计日志系统
  - [ ] 实现异步日志写入
  - [ ] 实现日志分片存储
  - [ ] 实现日志压缩策略
  - [ ] 实现日志分析功能

### 8.3 性能与测试
- [ ] 实现性能监控系统
  - [ ] 实现指标收集器
  - [ ] 实现性能分析器
  - [ ] 实现告警机制
  - [ ] 实现系统优化策略

- [ ] 完善测试框架
  - [ ] 实现属性测试
  - [ ] 实现混沌测试
  - [ ] 实现端到端测试
  - [ ] 实现持续集成测试
